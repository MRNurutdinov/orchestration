
# Лабораторная №2

### Плохой пример `Dockerfile_bad`



1. Использования "жирного образа":
   - Проблема в использовании тяжелого образа без необходимости и докачиванию туда уже минимальной базы, нужную для проекта.
   - Плохо, потому что приводит к увеличению веса образа.
   - В `Dockerfile_good` исправлено на slim версию языка программирования

2. Разделение команд на отдельные слои
   * Много RUN, часть из которых является лишними, а часть можно объеденить в один RUN
   * Убраны все лишние скачивания и действия и оставлены только скачивания библиотек проекта

3. Копирование всех файлов проекта
   * Проблема: Команда `COPY` копирует все файлы, среди которых может оказаться конфиденциальная информация, например в `.env`.
   * Увеличивает размер образа и увеличивая риск содержания не используемых проектом файлов
   * Может привести к увеличению размера образа ненужными файлами.
   * Снижает производительность процесса сборки.
   * Исправлено путём добавления только директории проекта
4. Настройки запуска:
   * Запуск в плохом образе происходит через ```CMD```, что не позволяет переопределить команду запуска контейнера извне
   * Может привести к несогласованности между образом и скриптом запуска.
   * Заменено на ```ENTRYPOINT```

## Плохие практики контейнеризации
1. Создание непрозрачных, запутанных Dockerfile'ов с магическими командами
2. Перенос практик виртуализации на контейнеры без понимания принципов иммутабельности и statelessness.
## Когда НЕ стоит применять контейнеры:
1. Когда требуется постоянное хранение данных. Контейнеры efemernny и не должны хранить данные на диске между запусками.
2. Для сложных систем с множеством зависимостей. Контейнеры лучше подходят для простых приложений с четко определенной функциональностью.

## Сборка и запуск

плохого
```bash
docker rmi -f bad_docker && docker build -f Dockerfile_bad -t bad_docker . && docker run -it bad_docker
```
хорошего
```bash
docker rmi -f good_docker && docker build -f Dockerfile_good -t good_docker . && docker run -it bad_docker
```